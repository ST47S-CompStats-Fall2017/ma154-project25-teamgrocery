---
title: "testdata"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

# Load data: only need to run once

#install.packages("data.table")
#library(data.table)
#ships <- fread('https://raw.githubusercontent.com/hopperrr/ellis-immigration-by-ship/gh-pages/data/trips.tsv')

# Total number of people from each ship

library('ggplot2')
#install.packages('ggthemes')
library('ggthemes')
library('scales')
library('dplyr')
#install.packages("mice")
library('mice')
#install.packages("randomForest")
library('randomForest')
#install.packages("class")
library('class')
#install.packages("data.table")
library('data.table')
library('lubridate')
library('caret')

```

```{r}

# This data import takes a while
#train <- fread("train.csv")

```

THIS CHUNK: Importing CSV files
```{r}

# This date import is quick
holidays <- fread("holidays_events.csv")
items <- fread("items.csv")
oil <- fread("oil.csv")
stores <- fread("stores.csv")

# Make sandbox train and test data
set.seed(888)
sandbox <- train[sample(.N, 15000),]


```

THIS CHUNK: Joining tables and renaming variables
```{r}

# Set names
cols <- names(holidays)[-1] # Except for date
setnames(holidays, (cols), paste("holiday_", (cols), sep=""))

cols <- names(items)[-1] # Except for item_nbr
setnames(items, (cols), paste("item_", (cols), sep=""))

setnames(oil, "dcoilwtico", "oil_price")

cols <- names(stores)[-1] # Except for store_nbr
setnames(stores, (cols), paste("store_", (cols), sep=""))

# Join with holidays_events
setkey(sandbox, date)
setkey(holidays, date)
sandbox <- merge(sandbox, holidays, all.x = TRUE)

# Join with items
setkey(sandbox, item_nbr)
setkey(items, item_nbr)
sandbox <- merge(sandbox, items, all.x = TRUE)

# Join with oil
setkey(sandbox, date)
setkey(oil, date)
sandbox <- merge(sandbox, oil, all.x = TRUE)

# Join with stores
setkey(sandbox, store_nbr)
setkey(stores, store_nbr)
sandbox <- merge(sandbox, stores, all.x = TRUE)

setkey(sandbox, id)

```

THIS CHUNK: Modifying the data - adding variables
```{r}

# Add cols for "year", "month", "day" (values 1-365)
sandbox[,c("year", "month", "day", "weekday") := 0]

dates_str <- sandbox$date
dates <- lapply(strsplit(dates_str, "-"), as.integer)
for (i in 1:length(dates)) {
  # Calculate vals
  date = dates[[i]]
  y = date[1]
  m = date[2]
  d = yday(ymd(dates_str[i])) # Day of year
  w = wday(ymd(dates_str[i])) # Day of week
  
  # Update table
  set(sandbox, i, "year", y)
  set(sandbox, i, "month", m)
  set(sandbox, i, "day", d)
  if (d < 15) {
    set(sandbox, i, "days_since_payday", d)  
  } else {
    set(sandbox, i, "days_since_payday", d - 15)
  }
  set(sandbox, i, "weekday", w)
}

# Make a categorical variable for each weekday
weekday_names <- c("Sun", "Mon", "Tues", "Weds", "Thurs", "Fri", "Sat")
for (i in 1:7) {
  weekday_name <- weekday_names[i]
  sandbox[,(weekday_name) := weekday == (i)]
}

# Make a categorical variable for each item family 
item_families <- unique(sandbox$item_family)
for (i in 1:length(item_families)) {
  cur_item_family <- item_families[i]
  sandbox[,(cur_item_family) := item_family == (cur_item_family)]
}

# Make a cat. var. for each store city
store_cities <- unique(sandbox$store_city)
for (i in 1:length(store_cities)) {
  cur_store_city <- store_cities[i]
  sandbox[,(cur_store_city) := store_city == (cur_store_city)]
}
# Make a binary variable for each store cluster
store_clusters <- unique(sandbox$store_cluster)
for (i in 1:length(store_clusters)) {
  cur_store_cluster <- store_clusters[i]
  sandbox[,(paste("Cluster", cur_store_cluster)) := store_cluster == (cur_store_cluster)]
}

# Make a binary variable for each store type
store_types <- unique(sandbox$store_type)
for (i in 1:length(store_types)) {
  cur_store_type <- store_types[i]
  sandbox[,(paste("Store Type", cur_store_type)) := store_type == (cur_store_type)]
}

#I want to convert the dates to days of the week as a predictive variable
sandbox <- sandbox %>% mutate( days_of_week = weekdays(as.Date(sandbox$date,'%Y-%m-%d')))

#General idea of when holidays happen in a specific location
sandbox <- sandbox %>% mutate(holiday = !is.na(holiday_type) &
                                        !holiday_transferred &
                                         holiday_type != "Work Day" &
                                        (holiday_locale == "National"|
                                        holiday_locale_name == store_city |
                                        holiday_locale_name == store_state))

#Work day variable
sandbox <- sandbox %>% mutate(work_day = holiday_type == "Work Day" & !is.na(holiday_type))

#Bring over holiday type where it is relevant to the sale
sandbox <- sandbox %>% mutate(holiday_type_relevant = ifelse(holiday, paste("holiday_",holiday_type,sep = ""), "holiday_None") )

setDT(sandbox)
holiday_type_relevant_vals <- unique(sandbox$holiday_type_relevant)
for (i in 1:length(holiday_type_relevant_vals)) {
  cur_holiday_type_relevant <- holiday_type_relevant_vals[i]
  sandbox[,(cur_holiday_type_relevant) := 
            holiday_type_relevant == (cur_holiday_type_relevant)]
}

# Adding months and days since Jan. 1 2013 (both starting at 1)
sandbox[,month_count := 12 * (year - 2013) + month]
sandbox[,day_count := 365 * (year - 2013) + day]

split_pt <- nrow(sandbox) * 0.7
s_train <- sandbox[1:split_pt,]
s_test <- sandbox[split_pt:nrow(sandbox),]
setDT(s_train)
setDT(s_test)

```

THIS CHUNK: Summary statistics and data visualization (graphs)
```{r}
#Let's create some summary statistics
for (i in 1:ncol(s_train)){
eval(parse(text = paste(paste("sales_table_",names(s_train)[i]," = ",sep = ""),
                        "s_train %>% group_by(",names(s_train)[i],
                        ") %>% summarize(sales = mean(unit_sales))")))
}
#Let's graph them
for (i in 1:ncol(s_train)){
eval(parse(text = paste(paste("sales_plot_",names(s_train)[i]," = ",sep = ""),
                        "s_train %>% group_by(",names(s_train)[i],
                        ") %>% summarize(sales = mean(unit_sales)) %>% 
                        ggplot() + geom_col(aes(x =as.factor(",names(s_train)[i],
                        "), y = sales))")))
}
#Let's also just get some simple frequency statistics
for (i in 1:ncol(s_train)){
eval(parse(text = paste(paste("freq_table_",names(s_train)[i]," = ",sep = ""),
                        "s_train %>% group_by(",names(s_train)[i],
                        ") %>% summarize(freq = n())")))
}
#Lets graph them
for (i in 1:ncol(s_train)){
eval(parse(text = paste(paste("freq_table_",names(s_train)[i]," = ",sep = ""),
                        "s_train %>% group_by(",names(s_train)[i],
                        ") %>% summarize(freq = n()) %>% ggplot() + 
                        geom_col(aes(x =as.factor(",names(s_train)[i],
                        "), y = sales))")))
}
#Input sales_plot, sales_table, freq_table or freq_plot and 
#then the variable for the plot like the example below

# See what types of items are most popular
item_families <- sort(table(s_train$item_family)/10703 * 100, decreasing = TRUE)
item_families
popular_items <- names(item_families[item_families > 2])

# Item trends
setDT(s_train)

# By month
grocery_trends <- s_train[item_family %in% (popular_items), j = .(total_sales = sum(unit_sales)), by = .(item_family, month)]
ggplot(data = grocery_trends) + geom_line(aes(x = month, y = total_sales, color = item_family)) + expand_limits(y = 0)

# By year
grocery_trends <- s_train[item_family %in% (popular_items), j = .(total_sales = sum(unit_sales)), by = .(item_family, year)]
ggplot(data = grocery_trends) + geom_line(aes(x = year, y = total_sales, color = item_family)) + expand_limits(y = 0)

# By day of week
grocery_trends <- s_train[item_family %in% (popular_items), j = .(total_sales = sum(unit_sales)), by = .(item_family, weekday)]
ggplot(data = grocery_trends) + geom_line(aes(x = weekday, y = total_sales, color = item_family)) + expand_limits(y = 0)

# By is weekend
grocery_trends <- s_train[item_family %in% (popular_items), j = .(total_sales = sum(unit_sales)), by = .(item_family, weekend)]
ggplot(data = grocery_trends) + geom_col(aes(x = weekend, y = total_sales, color = item_family), position="dodge", width=0.7) + expand_limits(y = 0)

```

THIS CHUNK: Setting up day variable for time series
1. Make table with 2 cols: day, total_sales (on that day)
2. Divide total sales by the number of stores included in the dataset on that day (number of stores in dataset increase over time, so we want to factor that out)
3. Linearize/difference???
```{r}

### STEP 1: Make table with 2 cols - day_count and sales
sales_per_day <- s_train[,j = .(sales = sum(unit_sales)), by = day_count]


### STEP 2: Divide by total stores open

# The largest day in the dataset
max_day <- max(s_train$day_count)

# See first and last sale of each store
store_data <- s_train[,j = .(first = min(day_count), last = max(day_count)), by=store_nbr]
store_data
# Shows that although some stores were added over time, no stores ever closed (they all have sales up through Aug. 2016)


### COUNT THE NUMBER OF STORES THAT ARE OPEN ON EACH DAY

# Array containing number of stores open, where day is the index ranging from 1 to max_day
stores_open <- c()
store_openings <- store_data$first
store_openings <- ifelse(store_openings < 50, 1, store_openings)
cur_stores_open <- 0

# Add to the array for each day
cur_day = 1
while (length(store_openings) > 0) {
  to_remove <- c()
  
  # Handle all stores that opened on this data
  for (i in 1:length(store_openings)) {
    if (store_openings[i] <= cur_day) {
      to_remove <- c(to_remove, i)
      cur_stores_open <- cur_stores_open + 1
    }
  }
  
  # Remove elements
  if (length(to_remove) > 0) {
      store_openings <- store_openings[-to_remove]
  }
  
  # Add to the array of stores open on each day
  stores_open <- c(stores_open, cur_stores_open)
  cur_day <- cur_day + 1
}

# Fill out array
while (cur_day <= max_day) {
  stores_open <- c(stores_open, cur_stores_open)
  cur_day <- cur_day + 1
}

### DONE COUNTING STORES OPEN ON EACH DAY

# Divide sales for each day by number of stores that were open
for (i in 1:nrow(sales_per_day)) {
  # Get stores open 
  cur_day_count = sales_per_day[i,day_count]
  cur_stores_open = stores_open[cur_day_count]
  
  # Modify sales
  cur_sales = sales_per_day[i, sales]
  cur_sales <- cur_sales / cur_stores_open 
  set(sales_per_day, i, "sales", cur_sales)
}
ggplot(data = sales_per_day) + geom_line(aes(x = day_count, y = sales)) + expand_limits(y = 0)


# Step 3: linearize/difference???

```


THIS CHUNK: 
1. Set the time series variable
2. Check for Stationarity
3. Difference to get stationarity
4. Apply ARIMA model
```{r}
View(s_train)
library(dplyr)
library('ggplot2')
#install.packages("forecast")
library('forecast')
library('tseries')
library(data.table)
#summarize unit sales by class for the day
daily_sales <- s_train %>% group_by(date, item_family) %>% summarise(daily_class_sales = sum(unit_sales))
#Just the vector of daily sales
daily_sales_ts <- daily_sales %>% filter(item_family == "GROCERY I")
ds_ts <- ts(daily_sales_ts$daily_class_sales, frequency = 7)
ds_adf <- adf.test(ds_ts, alternative = "stationary")
ds_adf
```


```{r}

time_series = data.table()
time_series_adf = data.table()

z <- 1
for (i in unique(daily_sales$item_family)){
  daily_sales_ts <- daily_sales %>% filter(item_family == i)
  ds_ts <- ts(daily_sales_ts$daily_class_sales, frequency = 7)
  time_series [,(i) := (ds_ts)]
  #time_series_adf <- c(time_series_adf, adf.test(time_series[z], alternative = "stationary"))
  z <- z + 1
}
View(time_series[1])
time_series
```


THIS CHUNK: Build and test the model
```{r}

# Run some model
model_cols <- c("unit_sales", item_families, "holiday", "work_day", paste("Cluster",store_clusters), store_cities, paste("Store Type", store_types), weekday_names)
s_train_model <- s_train[,model_cols, with=FALSE]
rf_model <- train(unit_sales ~ . , data=s_train_model, method="rf",
                  trControl = trainControl(method="oob"),  # Use the OOB error rate 
                  ntree=500, tuneGrid = data.frame(mtry=((length(model_cols) - 1))/3),
                  importance = TRUE)  # need this for variable importance below
predictions <- predict(rf_model, newdata = s_test)
actual <- s_test$unit_sales
accuracy <- sum((log(predictions + 1) - log(actual + 1)) ** 2) / length(predictions)
accuracy
View(s_train)
```
