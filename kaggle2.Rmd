---
title: "testdata"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Install packages
```{r}

# Load data: only need to run once

#install.packages("data.table")
#library(data.table)
#ships <- fread('https://raw.githubusercontent.com/hopperrr/ellis-immigration-by-ship/gh-pages/data/trips.tsv')

# Total number of people from each ship

library('ggplot2')
#install.packages('ggthemes')
library('ggthemes')
library('scales')
library('dplyr')
#install.packages("mice")
library('mice')
#install.packages("randomForest")
library('randomForest')
#install.packages("class")
library('class')
#install.packages("data.table")
library('data.table')
library('lubridate')
library('caret')

#install.packages('tseries')
library(tseries)


```

# Load data from CSV
```{r}

# This data import takes a while
#train <- fread("train.csv")

# This date import is quick
holidays <- fread("holidays_events.csv")
items <- fread("items.csv")
oil <- fread("oil.csv")
stores <- fread("stores.csv")

```

# Sections:
# 1. Joining tables
# 2. Sample a sandbox
# 3. Add variables
# 4. Split into transacted/non-transacted

# 1. Joining tables
```{r}

# Set names
cols <- names(holidays)[-1] # Except for date
setnames(holidays, (cols), paste("holiday_", (cols), sep=""))

cols <- names(items)[-1] # Except for item_nbr
setnames(items, (cols), paste("item_", (cols), sep=""))

setnames(oil, "dcoilwtico", "oil_price")

cols <- names(stores)[-1] # Except for store_nbr
setnames(stores, (cols), paste("store_", (cols), sep=""))

# Join with holidays_events
#setkey(train, date)
#setkey(holidays, date)
#train <- merge(train, holidays, all.x = TRUE)

# Join with items
setkey(train, item_nbr)
setkey(items, item_nbr)
train <- merge(train, items, all.x = TRUE)

# Join with oil
setkey(train, date)
setkey(oil, date)
train <- merge(train, oil, all.x = TRUE)

# Join with stores
setkey(train, store_nbr)
setkey(stores, store_nbr)
train <- merge(train, stores, all.x = TRUE)

```

# 2. Sample a sandbox
```{r}

# Reduced data set to work with
set.seed(888)
p <- 15000/125497040 # Proportion we want to sample
setkey(train, date)
ndt <- train[, .(n = .N), by = date]
indices <- c()
start <- end <- 1
num_days <- nrow(ndt)
for (i in 1:num_days) {
  n <- ndt[i,n]
  end <- start + n - 1
  new_indices <- sample(start:end, as.integer(n * p))
  new_indices
  indices <- c(indices, new_indices)
  start <- end + 1
}
sandbox <- train[indices,]

```

# 3. Add variables
```{r}

# Add cols for "year", "month", "day" (values 1-365)
sandbox[,c("year", "month", "day", "weekday") := 0]

dates_str <- sandbox$date
dates <- lapply(strsplit(dates_str, "-"), as.integer)
for (i in 1:length(dates)) {
  # Calculate vals
  date = dates[[i]]
  y = date[1]
  m = date[2]
  d = yday(ymd(dates_str[i])) # Day of year
  w = wday(ymd(dates_str[i])) # Day of week
  
  # Update table
  set(sandbox, i, "year", y)
  set(sandbox, i, "month", m)
  set(sandbox, i, "day", d)
  if (d < 15) {
    set(sandbox, i, "days_since_payday", d)  
  } else {
    set(sandbox, i, "days_since_payday", d - 15)
  }
  set(sandbox, i, "weekday", w)
}

# Make a categorical variable for each weekday
weekday_names <- c("Sun", "Mon", "Tues", "Weds", "Thurs", "Fri", "Sat")
for (i in 1:7) {
  weekday_name <- weekday_names[i]
  sandbox[,(weekday_name) := weekday == (i)]
}

# Make a categorical variable for each item family 
item_families <- unique(sandbox$item_family)
for (i in 1:length(item_families)) {
  cur_item_family <- item_families[i]
  sandbox[,(cur_item_family) := item_family == (cur_item_family)]
}

# Make a cat. var. for each store city
store_cities <- unique(sandbox$store_city)
for (i in 1:length(store_cities)) {
  cur_store_city <- store_cities[i]
  sandbox[,(cur_store_city) := store_city == (cur_store_city)]
}
# Make a binary variable for each store cluster
store_clusters <- unique(sandbox$store_cluster)
for (i in 1:length(store_clusters)) {
  cur_store_cluster <- store_clusters[i]
  sandbox[,(paste("Cluster", cur_store_cluster)) := store_cluster == (cur_store_cluster)]
}

# Make a binary variable for each store type
store_types <- unique(sandbox$store_type)
for (i in 1:length(store_types)) {
  cur_store_type <- store_types[i]
  sandbox[,(paste("Store Type", cur_store_type)) := store_type == (cur_store_type)]
}

#I want to convert the dates to days of the week as a predictive variable
sandbox <- sandbox %>% mutate( days_of_week = weekdays(as.Date(sandbox$date,'%Y-%m-%d')))

#General idea of when holidays happen in a specific location
sandbox <- sandbox %>% mutate(holiday = !is.na(holiday_type) &
                                        !holiday_transferred &
                                         holiday_type != "Work Day" &
                                        (holiday_locale == "National"|
                                        holiday_locale_name == store_city |
                                        holiday_locale_name == store_state))

#Work day variable
sandbox <- sandbox %>% mutate(work_day = holiday_type == "Work Day" & !is.na(holiday_type))

#Bring over holiday type where it is relevant to the sale
sandbox <- sandbox %>% mutate(holiday_type_relevant = ifelse(holiday, paste("holiday_",holiday_type,sep = ""), "holiday_None") )

setDT(sandbox)
holiday_type_relevant_vals <- unique(sandbox$holiday_type_relevant)
for (i in 1:length(holiday_type_relevant_vals)) {
  cur_holiday_type_relevant <- holiday_type_relevant_vals[i]
  sandbox[,(cur_holiday_type_relevant) := 
            holiday_type_relevant == (cur_holiday_type_relevant)]
}

# Adding months and days since Jan. 1 2013 (both starting at 1)
sandbox[,month_count := 12 * (year - 2013) + month]
sandbox[,day_count := 365 * (year - 2013) + day]

```

# 4. Split into transacted/non-transacted (Todo Thomas)

```{r}
sandbox = fread("sandbox.csv")
item_ids = unique(sandbox$id)
store_ids = unique(stores$store_nbr)
item_store_sales = data.table(matrix(0, nrow=length(item_ids), ncol=length(store_ids)))
for (i in 1:length(item_ids)) {
  for (j in 1:length(store_ids)) {
    cur_item_id = item_ids[i]
    cur_store_nbr = store_ids[j]
    item_store_sales[i,j] = nrow(sandbox[sandbox$id==cur_item_id && sandbox$store_nbr==cur_store_nbr])
  }
}

# Need actual matrix of days open for every store
total_days <- max(sandbox$day_count)
store_data <- sandbox[,j = .(days_open = (total_days) - min(day_count)), by=store_nbr]
setkey(store_data, store_nbr)
days_open <- store_data$days_open

days_open = matrix(1322, nrow=1, ncol=length(store_ids))

id_frequency = data.table(item_ids, rep(0,length(train_ids)))
colnames(id_frequency) = c("id", "ratio")
for (i in 1:length(item_ids)) {
  total_transaction_days = sum(item_store_sales[i,])
  days_open_of_stores_w_item = 0
  for (j in 1:length(store_ids)) {
    if (item_store_sales[i,j] > 0) {
      days_open_of_stores_w_item = days_open[1,store_ids[j]] + days_open_of_stores_w_item
    }
  }
  id_frequency[id_frequency$item_ids==item_ids[i]] = total_transaction_days / days_open_of_stores_w_item
}

popular_items = filter(id_frequency, ratio>0.95)
popular_items_ids = popular_items$id
```

# 5. Transacted: time series (Justin)

THIS CHUNK: 
1. Set the time series variable
2. Check for Stationarity
3. Difference to get stationarity
4. Apply ARIMA model
```{r}
View(s_train)
library(dplyr)
library('ggplot2')
#install.packages("forecast")
library('forecast')
library('tseries')
library(data.table)
#summarize unit sales by class for the day
daily_sales <- s_train %>% group_by(date, item_family) %>% summarise(daily_class_sales = sum(unit_sales))

daily_sales_ts <- daily_sales %>% filter(item_family == "GROCERY I")
ds_ts <- ts(daily_sales_ts$daily_class_sales, frequency = 7)
ds_adf <- adf.test(ds_ts, alternative = "stationary")
ds_adf
```


```{r}

time_series = data.table()
time_series_adf = data.table()

z <- 1
for (i in unique(daily_sales$item_family)){
  daily_sales_ts <- daily_sales %>% filter(item_family == i)
  ds_ts <- ts(daily_sales_ts$daily_class_sales, frequency = 7)
  time_series [,(i) := (ds_ts)]
  #time_series_adf <- c(time_series_adf, adf.test(time_series[z], alternative = "stationary"))
  z <- z + 1
}
View(time_series[1])
time_series
```

# 6. Transacted: random forest

# 7. Non-transacted: random forest